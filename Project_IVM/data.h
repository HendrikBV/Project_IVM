/*
	Copyright (c) 2024 KU Leuven
	Code author: Hendrik Vermuyten
*/



/*!
 *  @file       Data.h
 *  @brief      Defines the data for the IVM scheduling problem
 *
 *  This class is used to store all data that serve as input
 *  to the optimization models. Reading of data is done via
 *  XML files. Data should first be read in in an Instance
 *  object and that object is then passed to the optimization
 *  model objects so that an IP model can be built and solved.
 */

#pragma once
#ifndef DATA_H
#define DATA_H

#include <string>
#include <vector>
#include <unordered_map>
#include <exception>

namespace IVM
{
	/*!
	 *	@brief Class to store input/output all data
	 */
	class Instance
	{
		/*!
		 *	@brief To switch between indices and names for the days
		 */
		const std::unordered_map<std::string, int> _dag_naam_index{ {"maandag", 0}, {"dinsdag", 1}, {"woensdag", 2}, {"donderdag", 3}, {"vrijdag", 4} };

		/*!
		 *	@brief To switch between indices and names for the days
		 */
		const std::unordered_map<int, std::string> _naam_dag_index{ {0, "maandag"}, {1, "dinsdag"}, {2, "woensdag"}, {3, "donderdag"}, {4, "vrijdag"} };

		/*!
		 *	@brief The name of the instance
		 */
		std::string _name;

		/*!
		 *	@brief The number of days per week in the instance
		 */
		size_t _nb_days;

		/*!
		 *	@brief The number of weeks in the instance
		 */
		size_t _nb_weeks;

		/*!
		 *	@brief The maximum number of visits to every zone in the planning horizon
		 */
		size_t _max_visits;

		/*!
		 *	@brief The names of all waste types. Used to access by name instead of index
		 */
		std::vector<std::string> _waste_types;

		/*!
		 *	@brief To store information on the different collection points
		 */
		struct Collection_Point
		{
			/*!
			 *	@brief Name of the collection point
			 */
			std::string _name;

			/*!
			 *	@brief Allowed waste types at this collection point
			 */
			std::vector<std::string> _allowed_waste_types;

			/*!
			 *	@brief Driving time from this collection point to the depot
			 */
			double _driving_time_depot = 0.5;
		};

		/*!
		 *	@brief The collection points
		 */
		std::vector<Collection_Point> _collection_points;

		/*!
		 *	@brief	Stores the unloading times for the various types of waste (the same at all facilities)
		 *			string == type of waste; double == unloading time
		 */
		std::unordered_map<std::string, double> _waste_type_unloading_time;

		/*!
		 *	@brief To store information on the different types of trucks
		 */
		struct Truck
		{
			/*!
			 *	@brief Name of the truck
			 */
			std::string _name;

			/*!
			 *	@brief Maximum working hours per day
			 */
			double _max_hours;

			/*!
			 *	@brief Fixed costs for one truck
			 */
			double _fixed_costs;

			/*!
			 *	@brief Operating costs per hour
			 */
			double _operating_costs;

			/*!
			 *	@brief	The capacity of the truck for the various types of waste
			 *			string == waste type; double == capacity for that type
			 */
			std::unordered_map<std::string, double> _capacities;
		};

		/*!
		 *	@brief The types of trucks that can be used
		 */
		std::vector<Truck> _trucks;

		/*!
		 *	@brief To store information on the zones (customers)
		 */
		struct Zone
		{
			/*!
			 *	@brief Name of the zone (customer)
			 */
			std::string _name;

			/*!
			 *	@brief	Demand for the various types of waste
			 *			string == waste type; double == demand for that type
			 */
			std::unordered_map<std::string, double> _demands;

			/*!
			 *	@brief	Collection time for the various types of waste
			 *			string == waste type; double == collection time for that type
			 */
			std::unordered_map<std::string, double> _collection_times;

			/*!
			 *	@brief	Current pickup day for the various types of waste
			 *			string == waste type; double == current pickup day for that type
			 */
			std::unordered_multimap<std::string, int> _current_calendar_day; 

			/*!
			 *	@brief	Current pickup week for the various types of waste
			 *			string == waste type; double == current pickup week for that type
			 */
			std::unordered_multimap<std::string, int> _current_calendar_week; 

			/*!
			 *	@brief	Driving time from this zone to various destinations
			 *			string == destination; double == driving time
			 */
			std::unordered_map<std::string, double> _driving_time;

			/*!
			 *	@brief	Days on which a pickup is not allowed
			 */
			std::vector<int> _forbidden_days;
		};

		/*!
		 *	@brief To store information on the zones (customers)
		 */
		std::vector<Zone> _zones;

		///////////////////////////////////////////////////////////////////////

		/*!
		 *	@brief	The solution from the allocation model that serves as
		 *			input to the routing model 
		 */
		std::vector<double> _sol_alloc_x_tmdw;

		/*!
		 *	@brief	A Route generated by the routing model
		 */
		struct Route
		{
			/*!
			 *	@brief	The type of waste picked up on the route
			 */
			std::string _waste_type;

			/*!
			 *	@brief	The zones that are visited 
			 */
			std::vector<std::string> _pickups;

			/*!
			 *	@brief	The day on which this route is used (index of day)
			 */
			int _day = 0;

			/*!
			 *	@brief	The week on which this route is used (index of week)
			 */
			int _week = 0;

			/*!
			 *	@brief	The number of times the route is used
			 */
			int _nb_times_used = 0;
		};

		/*!
		 *	@brief	The routes generated by the routing model
		 */
		std::vector<Route> _routes;

	public:
		/*!
		 *	@brief Obtain data from an XML file
		 *  @param	filename	The name of the XML file
		 */
		void read_data_xml(const std::string& filename);

		/*!
		 *	@brief Obtain the allocation (amounts to be pick up on which days) from an XML file
		 *  @param	filename	The name of the XML file
		 */
		void read_allocation_xml(const std::string& filename);

		/*!
		 *	@brief Obtain the
		 *  @param	filename	The name of the XML file
		 */
		void read_routes_xml(const std::string& filename);

		/*!
		 *	@brief Clear all data
		 */
		void clear_data();

		/*!
		 *	@brief Get the number of waste types
		 *  @returns	The number of waste types
		 */
		size_t nb_waste_types() const { return _waste_types.size(); }

		/*!
		 *	@brief Get the number of truck types
		 *  @returns	The number of truck types
		 */
		size_t nb_truck_types() const { return _trucks.size(); }

		/*!
		 *	@brief Get the number of zones
		 *  @returns	The number of zones
		 */
		size_t nb_zones() const { return _zones.size(); }

		/*!
		 *	@brief Get the number of collection points
		 *  @returns	The number of collection points
		 */
		size_t nb_collection_points() const { return _collection_points.size(); }

		/*!
		 *	@brief Get the number of days per week
		 *  @returns	The number of days 
		 */
		size_t nb_days() const { return _nb_days; }

		/*!
		 *	@brief Get the number of weeks
		 *  @returns	The number of weeks
		 */
		size_t nb_weeks() const { return _nb_weeks; }

		/*!
		 *	@brief Get the maximum number of visits to every zone
		 *  @returns	The maximum number of visits
		 */
		size_t max_visits() const { return _max_visits; }

		/*!
		 *	@brief Get the name of the instance
		 *  @returns	The name of the instance
		 */
		const std::string& name_instance() const { return _name; }

		/*!
		 *	@brief Get the name of a given day
		 *  @param	index	The index for the day
		 *  @returns	The name of the day
		 */
		const std::string& day_name(size_t index) const { return _naam_dag_index.at(index); }

		/*!
		 *	@brief Get the name of a waste type
		 *  @param	index	The index for the waste type
		 *  @returns	The name of the waste type
		 */
		const std::string& waste_type(size_t index) const { return _waste_types[index]; }

		/*!
		 *	@brief Get the name of a zone
		 *  @param	index	The index for the zone
		 *  @returns	The name of the zone
		 */
		const std::string& zone_name(size_t index) const { return _zones[index]._name; }

		/*!
		 *	@brief Get the name of a truck type
		 *  @param	index	The index for the truck type
		 *  @returns	The name of the truck type
		 */
		const std::string& truck_type(size_t index) const { return _trucks[index]._name; }

		/*!
		 *	@brief Get the name of a collection point
		 *  @param	index	The index for the collection point
		 *  @returns	The name of the collection point
		 */
		const std::string& collection_point_name(size_t index) const { return _collection_points[index]._name; }

		/*!
		 *	@brief Find out whether a certain type of waste can be dropped off at a certain collection
		 *  @param	index	The index for the collection point
		 *  @param	waste_type	The name of the type of waste
		 *  @returns	True if the given type of waste can be dropped off at this collection point, false otherwise
		 */
		bool collection_point_waste_type_allowed(size_t index, const std::string& waste_type) const;

		/*!
		 *	@brief Get the demand for a given waste type in a given zone
		 *  @param	zone	The index for the zone
		 *  @param	waste_type	The name of the waste type
		 *  @returns	The demand in the given zone for the given waste type
		 */
		double demand(int zone, const std::string& waste_type) const { return _zones[zone]._demands.at(waste_type); }

		/*!
		 *	@brief Check whether there is a pickup on a certain day of a given week for a given waste type in a given zone
		 *  @param	zone	The index for the zone
		 *  @param	waste_type	The name of the waste type
		 *  @param	day	The index for the day
		 *  @param	week	The index for the week
		 *  @returns	True if there is a pickup on that day, false if not
		 */
		bool current_calendar(size_t zone, const std::string& waste_type, size_t day, size_t week) const;

		/*!
		 *	@brief Check whether pickups are forbidden in a given zone on a given day
		 *  @param	zone	The index for the zone
		 *  @param	day		The day
		 *  @returns	True if pickups are forbidden, false otherwise
		 */
		bool zone_forbidden_day(size_t zone, size_t day) const;

		/*!
		 *	@brief Get the number of pickups in the current calendar
		 *  @returns	The number of pickups
		 */
		size_t nb_pickups_current_calendar() const;

		/*!
		 *	@brief Get the operating costs per hour for a truck of a given type
		 *  @param	truck_type	The index for the truck type
		 *  @returns	The operating costs for that truck type
		 */
		double operating_costs(size_t truck_type) const { return _trucks[truck_type]._operating_costs; }

		/*!
		 *	@brief Get the name of a waste type
		 *  @param	index	The index for the waste type
		 *  @returns	The name of the waste type
		 */
		double fixed_costs(size_t truck_type) const { return _trucks[truck_type]._fixed_costs; }

		/*!
		 *	@brief Get the driving time from a given zone to a given collection point
		 *  @param	index	The index for the zone
		 *  @param	collection_point	The name of the collection point
		 *  @returns	The driving time
		 */
		double time_driving_zone_collectionpoint(size_t zone, const std::string& collection_point) const { return _zones[zone]._driving_time.at(collection_point); }

		/*!
		 *	@brief Get the driving time from a given zone to the depot
		 *  @param	index	The index for the zone
		 *  @returns	The driving time
		 */
		double time_driving_zone_depot(size_t zone) const { return _zones[zone]._driving_time.at("Depot"); }

		/*!
		 *	@brief Get the driving time from a given collection point to the depot
		 *  @param	index	The index for the collection point
		 *  @returns	The driving time
		 */
		double time_driving_collectionpoint_depot(size_t index) const { return _collection_points[index]._driving_time_depot; }

		/*!
		 *	@brief Get the pickup time per unit of waste for a given type of waste at a given zone
		 *  @param	index	The index for the zone
		 *  @param	waste_type	The name of the waste time
		 *  @returns	The pickup time
		 */
		double time_pickup(size_t zone, const std::string& waste_type) const { return _zones[zone]._collection_times.at(waste_type); }

		/*!
		 *	@brief Get the (fixed) unloading time for a given type of waste 
		 *  @param	waste_type	The name of the type of waste
		 *  @returns	The unloading time
		 */
		double time_unloading(const std::string& waste_type) const { return _waste_type_unloading_time.at(waste_type); }

		/*!
		 *	@brief Get the maximum driving time for a given type of truck
		 *  @param	index	The index for the type of truck
		 *  @returns	The the maximum driving time
		 */
		double max_driving_time(size_t truck_type) const { return _trucks[truck_type]._max_hours; }

		/*!
		 *	@brief Get the capacity of a given type of truck for a given type of waste
		 *  @param	index	The index for the type of truck
		 *  @param	waste_type	The name of the type of waste
		 *  @returns	The capacity
		 */
		double capacity(size_t truck_type, const std::string& waste_type) const { return _trucks[truck_type]._capacities.at(waste_type); }

		/*!
		 *	@brief Get the solution from the allocation model
		 *  @param	waste_type	Index of the waste type
		 *  @param	zone	Index of the zone
		 *  @param	day	Index of the day
		 *  @param	week	Index of the week
		 *  @returns	The amount of waste of the given type to pick up on the given day and week in the given zone
		 */
		double x_tmdw(size_t waste_type, size_t zone, size_t day, size_t week) const;

		/*!
		 *	@brief	Set the solution from the allocation model
		 *  @param	x	The values of the x_tmdw variables
		 */
		void set_solution_x(const std::vector<double>& x) { _sol_alloc_x_tmdw = x; }

		/*!
		 *	@brief	Get the number of generated routes
		 *  @returns	The number of routes
		 */
		size_t nb_routes() const { return _routes.size(); }

		/*!
		 *	@brief	Get a route based on its index
		 *  @returns	The index of the route
		 */
		const Route& route(size_t index_route) const { return _routes[index_route]; }

		/*!
		 *	@brief	Get the number of times a given route is used
		 *  @param	index_route		The index for the route
		 *  @returns	The number of times the route is used
		 */
		size_t route_nb_times_used(size_t index_route) const { return _routes[index_route]._nb_times_used; }

		/*!
		 *	@brief	See if a route visits a given zone
		 *  @param	index_route		The index for the route
		 *  @param	index_zone		The index for the zone
		 *  @returns	True if the route visits the zone, false otherwise
		 */
		bool route_visits_zone(size_t index_route, size_t index_zone) const;

		/*!
		 *	@brief	Get the name of the waste type that is picked up on the route
		 *  @param	index_route		The index for the route
		 *  @returns	The name of the waste type
		 */
		const std::string& route_waste_type_name(size_t index_route) const { return _routes[index_route]._waste_type; }

		/*!
		 *	@brief	See if a route picks up a given type of waste
		 *  @param	index_route		The index for the route
		 *  @param	waste_type		Name of the waste type
		 *  @returns	True if the route picks up the given type of waste, false otherwise
		 */
		bool route_waste_type(size_t index_route, const std::string& waste_type) const { return (_routes[index_route]._waste_type == waste_type); }

	};
}

#endif // !DATA_H
